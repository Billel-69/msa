{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Lenovo\\\\OneDrive\\\\Documents\\\\GitHub\\\\msa\\\\frontend\\\\src\\\\components\\\\MathJaxProcessor.jsx\";\nimport React from 'react';\nimport 'katex/dist/katex.min.css';\nimport { BlockMath, InlineMath } from 'react-katex';\n\n// Composant pour traiter le rendu mathématique\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst MathJaxProcessor = ({\n  text\n}) => {\n  // Découpe le contenu en segments: texte, math inline et math block\n  const processText = () => {\n    const result = [];\n    let currentText = '';\n    let remainingText = text;\n\n    // Expression régulière améliorée pour capturer les blocs et les expressions inline\n    // Utilise des lookahead/lookbehind pour éviter les faux positifs\n    const regex = /(?<!\\$)(\\$\\$[\\s\\S]*?\\$\\$)|(?<!\\$)(\\$[^\\$\\n]+?\\$)(?!\\$)/g;\n    let match;\n    let lastIndex = 0;\n    while ((match = regex.exec(remainingText)) !== null) {\n      // Ajouter le texte avant la formule\n      if (match.index > lastIndex) {\n        result.push({\n          type: 'text',\n          content: remainingText.substring(lastIndex, match.index)\n        });\n      }\n\n      // Déterminer si c'est une formule bloc ou inline\n      const formula = match[0];\n      if (formula.startsWith('$$') && formula.endsWith('$$')) {\n        // Formule bloc\n        result.push({\n          type: 'block-math',\n          content: formula.slice(2, -2) // Enlever les $$\n        });\n      } else {\n        // Formule inline\n        result.push({\n          type: 'inline-math',\n          content: formula.slice(1, -1) // Enlever les $\n        });\n      }\n      lastIndex = match.index + formula.length;\n    }\n\n    // Ajouter le texte restant\n    if (lastIndex < remainingText.length) {\n      result.push({\n        type: 'text',\n        content: remainingText.substring(lastIndex)\n      });\n    }\n    return result;\n  };\n\n  // Traiter les sauts de ligne dans le texte\n  const renderTextWithLineBreaks = textContent => {\n    return textContent.split('\\n').map((line, i, array) => /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: [line, i < array.length - 1 && /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 34\n      }, this)]\n    }, i, true, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 7\n    }, this));\n  };\n\n  // Rendu du contenu traité\n  const segments = processText();\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: segments.map((segment, index) => {\n      if (segment.type === 'text') {\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          children: renderTextWithLineBreaks(segment.content)\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 75,\n          columnNumber: 18\n        }, this);\n      } else if (segment.type === 'inline-math') {\n        try {\n          return /*#__PURE__*/_jsxDEV(InlineMath, {\n            math: segment.content\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 78,\n            columnNumber: 20\n          }, this);\n        } catch (error) {\n          console.error(\"Erreur de rendu MathJax inline:\", error, segment.content);\n          return /*#__PURE__*/_jsxDEV(\"span\", {\n            style: {\n              color: \"red\"\n            },\n            children: [\"$\", segment.content, \"$\"]\n          }, index, true, {\n            fileName: _jsxFileName,\n            lineNumber: 81,\n            columnNumber: 20\n          }, this);\n        }\n      } else if (segment.type === 'block-math') {\n        try {\n          return /*#__PURE__*/_jsxDEV(BlockMath, {\n            math: segment.content\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 85,\n            columnNumber: 20\n          }, this);\n        } catch (error) {\n          console.error(\"Erreur de rendu MathJax block:\", error, segment.content);\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              color: \"red\"\n            },\n            children: [\"$$\", segment.content, \"$$\"]\n          }, index, true, {\n            fileName: _jsxFileName,\n            lineNumber: 88,\n            columnNumber: 20\n          }, this);\n        }\n      }\n      return null;\n    })\n  }, void 0, false);\n};\n_c = MathJaxProcessor;\nexport default MathJaxProcessor;\nvar _c;\n$RefreshReg$(_c, \"MathJaxProcessor\");","map":{"version":3,"names":["React","BlockMath","InlineMath","jsxDEV","_jsxDEV","Fragment","_Fragment","MathJaxProcessor","text","processText","result","currentText","remainingText","regex","match","lastIndex","exec","index","push","type","content","substring","formula","startsWith","endsWith","slice","length","renderTextWithLineBreaks","textContent","split","map","line","i","array","children","fileName","_jsxFileName","lineNumber","columnNumber","segments","segment","math","error","console","style","color","_c","$RefreshReg$"],"sources":["C:/Users/Lenovo/OneDrive/Documents/GitHub/msa/frontend/src/components/MathJaxProcessor.jsx"],"sourcesContent":["import React from 'react';\r\nimport 'katex/dist/katex.min.css';\r\nimport { BlockMath, InlineMath } from 'react-katex';\r\n\r\n// Composant pour traiter le rendu mathématique\r\nconst MathJaxProcessor = ({ text }) => {\r\n  // Découpe le contenu en segments: texte, math inline et math block\r\n  const processText = () => {\r\n    const result = [];\r\n    let currentText = '';\r\n    let remainingText = text;\r\n    \r\n    // Expression régulière améliorée pour capturer les blocs et les expressions inline\r\n    // Utilise des lookahead/lookbehind pour éviter les faux positifs\r\n    const regex = /(?<!\\$)(\\$\\$[\\s\\S]*?\\$\\$)|(?<!\\$)(\\$[^\\$\\n]+?\\$)(?!\\$)/g;\r\n    let match;\r\n    let lastIndex = 0;\r\n    \r\n    while ((match = regex.exec(remainingText)) !== null) {\r\n      // Ajouter le texte avant la formule\r\n      if (match.index > lastIndex) {\r\n        result.push({\r\n          type: 'text',\r\n          content: remainingText.substring(lastIndex, match.index)\r\n        });\r\n      }\r\n      \r\n      // Déterminer si c'est une formule bloc ou inline\r\n      const formula = match[0];\r\n      if (formula.startsWith('$$') && formula.endsWith('$$')) {\r\n        // Formule bloc\r\n        result.push({\r\n          type: 'block-math',\r\n          content: formula.slice(2, -2) // Enlever les $$\r\n        });\r\n      } else {\r\n        // Formule inline\r\n        result.push({\r\n          type: 'inline-math',\r\n          content: formula.slice(1, -1) // Enlever les $\r\n        });\r\n      }\r\n      \r\n      lastIndex = match.index + formula.length;\r\n    }\r\n    \r\n    // Ajouter le texte restant\r\n    if (lastIndex < remainingText.length) {\r\n      result.push({\r\n        type: 'text',\r\n        content: remainingText.substring(lastIndex)\r\n      });\r\n    }\r\n    \r\n    return result;\r\n  };\r\n  \r\n  // Traiter les sauts de ligne dans le texte\r\n  const renderTextWithLineBreaks = (textContent) => {\r\n    return textContent.split('\\n').map((line, i, array) => (\r\n      <React.Fragment key={i}>\r\n        {line}\r\n        {i < array.length - 1 && <br />}\r\n      </React.Fragment>\r\n    ));\r\n  };\r\n  \r\n  // Rendu du contenu traité\r\n  const segments = processText();\r\n  \r\n  return (\r\n    <>\r\n      {segments.map((segment, index) => {\r\n        if (segment.type === 'text') {\r\n          return <span key={index}>{renderTextWithLineBreaks(segment.content)}</span>;\r\n        } else if (segment.type === 'inline-math') {\r\n          try {\r\n            return <InlineMath key={index} math={segment.content} />;\r\n          } catch (error) {\r\n            console.error(\"Erreur de rendu MathJax inline:\", error, segment.content);\r\n            return <span key={index} style={{color: \"red\"}}>${segment.content}$</span>;\r\n          }\r\n        } else if (segment.type === 'block-math') {\r\n          try {\r\n            return <BlockMath key={index} math={segment.content} />;\r\n          } catch (error) {\r\n            console.error(\"Erreur de rendu MathJax block:\", error, segment.content);\r\n            return <div key={index} style={{color: \"red\"}}>$${segment.content}$$</div>;\r\n          }\r\n        }\r\n        return null;\r\n      })}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default MathJaxProcessor;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}